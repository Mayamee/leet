/*
* В реализации мы сохраняем не сам минимальный элемент, а его индекс в массиве. 
* Это нужно потому, что в конце каждого прохода минимальный элемент записывается в начало массива. При этом элемент, 
* который был там до этого, нужно вставить куда-то в неупорядоченную половину — легче всего просто поменять их местами.
*
*/
function selectSort<T>([...arr]: T[]): T[] {
  const swap = <T>(idx1: number, idx2: number, arr: T[]): void => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i; // установил min index в элемент с которым возможно будет произведен обмен
    for (let j = i + 1; j < arr.length; j++) { // шагаем со следующего элемента и ищем индекс элемента который меньше чем
      if (arr[j] < arr[minIndex]) minIndex = j; // выбранный элемент и перезаписываем индекс если меньше
    }
    swap(i, minIndex, arr); // В конце обхода цикла меняем местами наш элемент и самый минимальный который идет дальше
  }
  return arr; // после прохода всего цикла у нас возвращается отсортированный массив
}
const arr1 = [9, 8, 7, 6, 5, 4, 3];
console.log(selectSort(arr1));
